## Infrastructure vs Application Deployment Separation

There are two distinct deployment phases, each with its own automated PowerShell script.

### Phase 1: Infrastructure Deployment

Run the infrastructure deployment script:

    .\deploy-infra\deploy.ps1 -ResourceGroup "rg-yourapp-YYYYMMDD" -Location "uksouth"

Important: Always use a unique resource group name (include date/time suffix). Reusing resource groups with partially deployed resources can cause ARM caching issues, particularly with Log Analytics Workspace references that result in "Could not retrieve the Log Analytics workspace from ARM" errors.

This script handles everything automatically: Azure CLI validation, credential retrieval, resource group creation, Bicep deployment, SQL Server configuration, firewall rules, database schema import, stored procedures, managed identity permissions, and App Service settings.

**Critical: The infrastructure deployment script MUST configure the App Service with:**
- `ConnectionStrings__DefaultConnection` - The SQL connection string with Managed Identity authentication
- `AZURE_CLIENT_ID` - The user-assigned managed identity client ID

Without these settings, the application will fail to connect to the database with errors like "System.InvalidOperationException: A relational store has been configured without specifying either the DbConnection or connection string to use."

At the end, the script saves a deployment context file (.deployment-context.json) containing all the resource names and configuration values needed for the next phase.

### Phase 2: Application Deployment

After infrastructure deployment completes, run the application deployment script with no parameters:

    .\deploy-app\deploy.ps1

The script automatically reads the deployment context file created by the infrastructure script, so you don't need to specify the resource group or web app name. It builds the .NET application, creates a deployment package, and deploys to Azure App Service.

### Seamless Deployment Flow

The two scripts are designed to work together without manual parameter entry between them. The deployment context file passes resource names and configuration values from infrastructure deployment to application deployment automatically.

### Known Issues and Workarounds

1. VS Code integrated terminal may use cached PATH: If sqlcmd produces errors about unrecognized arguments, the terminal may be using the legacy ODBC sqlcmd instead of modern go-sqlcmd. Either restart VS Code or run from a standalone PowerShell terminal.

2. PowerShell argument parsing: The --authentication-method argument must be quoted in PowerShell scripts to prevent parsing errors.

3. Resource group reuse: Always use fresh resource group names. If a deployment fails partway through, delete the resource group before retrying.

### Bicep Guidelines

Use uniqueString(resourceGroup().id) to generate deterministic unique names for resources. Never use timestamps like utcNow() in variable declarations as this is not allowed in Bicep.

Key considerations for Bicep templates:

- The utcNow() function can only be used as a parameter default value, not in variable declarations
- Conditional module outputs must use null-safe operators (?. and ??) to prevent errors when optional modules are not deployed
- All resource names should be lowercase to comply with Azure naming requirements
- Do not configure diagnostic settings at the SQL Server level as categories like SQLSecurityAuditEvents are not supported - only configure diagnostics at the database level
