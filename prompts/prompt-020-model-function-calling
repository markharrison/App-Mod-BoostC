Enable the chat interface to actually DO things, not just answer questions.

Using Azure OpenAI's function calling feature, let the AI assistant execute real operations against the database through the application's APIs. For example, when a user says "add an expense for Â£50 for lunch", the AI should actually create that expense.

Example of defining tools:

    var options = new ChatCompletionOptions
    {
        Tools = { 
            ChatTool.CreateFunctionTool("get_expenses", "Retrieves expenses from database"),
            ChatTool.CreateFunctionTool("create_expense", "Creates a new expense record")
        }
    };

## What to Build

### 1. Identify Available Operations

Look at the existing service methods and figure out which ones should be available to the AI:

- What can users query? (get expenses, list categories, etc.)
- What can users create or modify? (add expense, approve expense, etc.)
- What parameters does each operation need?

### 2. Define Functions for the AI

For each operation, create a function tool definition with:

- A clear, descriptive name
- A helpful description explaining what it does
- JSON schema for the parameters (types, descriptions, required vs optional)

### 3. Handle the Conversation Loop

The function calling flow works like this:

1. Send the user's message to the AI along with the available functions
2. If the AI decides to call a function, it returns a tool_call instead of a message
3. Execute that function against your actual services
4. Send the result back to the AI
5. The AI might call more functions or return a final response
6. Show the user-friendly response to the user

### 4. Handle Errors Gracefully

- If a service call fails, tell the AI what went wrong so it can explain to the user
- Validate function arguments before executing
- Log errors for debugging

### 5. Update the System Prompt

Tell the AI what it can do:

- List the available functions
- Explain when to use each one
- Give guidance on confirming actions with users

### Important

Only modify the chat service layer. Don't change the existing APIs or data access code - use dependency injection to access those services from the chat service.
